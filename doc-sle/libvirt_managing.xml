<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter
[
  <!ENTITY % entities SYSTEM "entity-decl.ent">
    %entities;
]>
<!-- Converted by suse-upgrade version 1.1 -->
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0" xml:id="cha.libvirt.managing">
 <title>Basic &vmguest; Management</title>
 <info/>
 <para>
  Most management tasks, such as starting or stopping a &vmguest;, can
  either be done using the graphical application &vmm; or on the command
  line using <command>virsh</command>. Connecting to the graphical console
  via VNC is only possible from a graphical user interface.
 </para>
 <note>
  <title>Managing &vmguest;s on a Remote &vmhost;</title>
  <para>
   If started on a &vmhost; the &libvirt; tools &vmm;
   <command>virsh</command> and <command>virt-viewer</command>can be used to
   manage &vmguest;s on the host. However, it is also possible to manage
   &vmguest;s on a remote &vmhost;. This requires to configure remote
   access for &libvirt; on the host. See
   <xref linkend="cha.libvirt.connect"/> for instructions.
  </para>
  <para>
   In order to connect to such a remote host with &vmm;, you need to set
   up a connection as explained in
   <xref linkend="sec.libvirt.connect.connecting.vmm"/>. If connecting to a
   remote host using <command>virsh</command> or
   <command>virt-viewer</command>, you need to specify a connection URI with
   the parameter <option>-c</option> (for example <command>virsh -c
   qemu+tls://&wsIIIname;/system</command> or <command>virsh -c
   xen+ssh://</command>). The form of connection URI depends on the
   connection type and the hypervisor&mdash;see
   <xref linkend="sec.libvirt.connect.connecting"/> for details.
  </para>
  <para>
   Examples in this chapter are all listed without a connection URI.
  </para>
 </note>
 <sect1 xml:id="sec.libvirt.managing.list">
  <title>Listing &vmguest;s</title>

  <para>
   The &vmguest; listing shows all &vmguest;s managed by &libvirt;
   on a &vmhost;.
  </para>

  <sect2 xml:id="sec.libvirt.managing.list.vmm">
   <title>Listing &vmguest;s with &vmm;</title>
   <para>
    The main window of the &vmm; shows a list of all &vmguest;s for
    each &vmhost; it is connected to. Each &vmguest; entry contains
    the machine's name, its status (<guimenu>Running</guimenu>,
    <guimenu>Paused</guimenu>, or <guimenu>Shutoff</guimenu>) displayed as
    icon and literally, and a CPU usage bar.
   </para>
  </sect2>

  <sect2 xml:id="sec.libvirt.managing.list.virsh">
   <title>Listing &vmguest;s with <command>virsh</command></title>
   <para>
    Use the command <command>virsh</command> <option>list</option> to get a
    list of &vmguest;s:
   </para>
   <variablelist>
    <varlistentry>
     <term>List all running guests
     </term>
     <listitem>
<screen>virsh list</screen>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>List all running and inactive guests</term>
     <listitem>
<screen>virsh --all</screen>
     </listitem>
    </varlistentry>
   </variablelist>
   <para>
    For more information and further options, see <command>virsh help
    list</command> or <command>man 1 virsh</command>.
   </para>
  </sect2>
 </sect1>
 <sect1 xml:id="sec.libvirt.managing.vnc">
  <title>Opening a Graphical Console</title>

  <para>
   Opening a Graphical Console to a &vmguest; lets you interact with the
   machine like a physical host via a VNC connection. If accessing the VNC
   server requires authentication, you are prompted to enter a user name (if
   applicable) and a password.
  </para>

  <para>
   Once you click into the VNC console, the cursor is <quote>grabbed</quote>
   and cannot be used outside the console anymore. To release it, press
   <keycombo> <keycap function="alt"/> <keycap function="control"/>
   </keycombo>.
  </para>

  <tip>
   <title>Seamless (Absolute) Cursor Movement</title>
   <para>
    In order to prevent the console from grabbing the cursor and to enable
    seamless cursor movement, add a tablet input device to the &vmguest;.
    See <xref linkend="sec.libvirt.config.tablet"/> for more information.
   </para>
  </tip>

  <para>
   Certain key combinations such as <keycombo> <keycap function="control"/>
   <keycap function="alt"/> <keycap function="delete"/> </keycombo> are
   interpreted by the host system and are not passed to the &vmguest;. To
   pass such key combinations to a &vmguest;, open the <guimenu>Send
   Key</guimenu> menu from the VNC window and choose the desired key
   combination entry. The <guimenu>Send Key</guimenu> menu is only available
   when using &vmm; and <command>virt-viewer</command>. With &vmm; you
   can alternatively use the <quote>sticky key</quote> feature as explained
   in <xref linkend="tip.libvirt.inst.vmm.sticky"/>.
  </para>

  <note>
   <title>Supported VNC Viewer</title>
   <para>
    Principally all VNC viewers are able to connect to the console of a
    &vmguest;. However, if you are using SASL authentication and/or
    TLS/SSL connection to access the guest, the options become limited.
    Common VNC viewers such as <literal>tigervnc</literal> support neither
    SASL authentication nor TSL/SSL. The only supported alternative to
    &vmm; and <command>virt-viewer</command> is
    <command>vinagre</command>.
   </para>
  </note>

  <sect2 xml:id="sec.libvirt.managing.vnc.vmm">
   <title>Opening a Graphical Console with &vmm;</title>
   <procedure>
    <step>
     <para>
      In the &vmm;, right-click a &vmguest; entry.
     </para>
    </step>
    <step>
     <para>
      Choose <guimenu>Open</guimenu> from the pop-up menu.
     </para>
    </step>
   </procedure>
  </sect2>

  <sect2 xml:id="sec.libvirt.managing.vnc.viewer">
   <title>Opening a Graphical Console with <command>virt-viewer</command></title>
   <para>
    <command>virt-viewer</command> is a simple VNC viewer with added
    functionality for displaying &vmguest; consoles. It can, for example,
    be started in <quote>wait</quote> mode, where it waits for a
    &vmguest; to start before it connects. It also supports automatically
    reconnecting to a &vmguest; that is rebooted.
   </para>
   <para>
    <command>virt-viewer</command> addresses &vmguest;s by name, by ID or
    by UUID. Use <command>virsh</command> <option>list --all</option> to get
    this data.
   </para>
   <para>
    To connect to a guest that is running or paused, use either the ID,
    UUID, or name. &vmguest;s that are shut off do not have an
    ID&mdash;you can only connect by UUID or name.
   </para>
   <variablelist>
    <varlistentry>
     <term>Connect to guest with the ID <literal>8</literal>
     </term>
     <listitem>
<screen>virt-viewer 8</screen>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>Connect to the inactive guest named <literal>sles12</literal>; the
     connection window will open once the guest starts</term>
     <listitem>
<screen>virt-viewer --wait sles12</screen>
      <para>
       With the <option>--wait</option> option, the connection will be
       upheld even if the &vmguest; is not running at the moment. Once
       the guest starts, the viewer will be launched.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
   <para>
    For more information, see <command>virt-viewer</command>
    <option>--help</option> or <command>man 1 virt-viewer</command>.
   </para>
   <note>
    <title>Password Input on Remote connections with SSH</title>
    <para>
     When using <command>virt-viewer</command> to open a connection to a
     remote host via SSH, the SSH password needs to be entered twice. The
     first time for authenticating with &libvirt;, the second time for
     authenticating with the VNC server. The second password needs to be
     provided on the command line where virt-viewer was started.
    </para>
   </note>
  </sect2>
 </sect1>
 <sect1 xml:id="sec.libvirt.managing.status">
  <title>Changing a &vmguest;'s State: Start, Stop, Pause</title>

  <para>
   Starting, stopping or pausing a &vmguest; can be done with either
   &vmm; or <command>virsh</command>. You can also configure a
   &vmguest; to be automatically started when booting the &vmhost;.
  </para>

  <para>
   When shutting down a &vmguest;, you may either shut it down
   gracefully, or force the shutdown. The latter is equivalent to pulling
   the power plug on a physical host and is only recommended if there are no
   alternatives. Forcing a shutdown may cause file system corruption and
   loss of data on the &vmguest;.
  </para>

  <tip>
   <title>Graceful Shutdown</title>
   <para>
    In order to be able to perform a graceful shutdown, the &vmguest;
    must be configured to support <xref linkend="gloss.vt.acpi"/>. If you
    have created the guest with <command>vm-install</command> or with
    &vmm;, <xref linkend="gloss.vt.acpi"/> should be available. Use the
    following procedure in &vmm; to check:
   </para>
   <para>
    Double-click the &vmguest; entry in &vmm;. Choose <menuchoice>
    <guimenu>View</guimenu> <guimenu>Details</guimenu> </menuchoice> and
    then <menuchoice> <guimenu>Overview</guimenu> <guimenu>Machine
    Settings</guimenu></menuchoice>. <guimenu>ACPI</guimenu> should be
    checked.
   </para>
   <para>
    Depending on the guest operating system, enabling
    <xref linkend="gloss.vt.acpi"/> may not be sufficient. It is strongly
    recommended to test shutting down and rebooting a guest before releasing
    it to production. &opensuse; or &sled;, for example, may require
    &pk; authorization for shutdown and reboot. Make sure this policy is
    turned off on all &vmguest;s.
   </para>
   <para>
    If <xref linkend="gloss.vt.acpi"/> was enabled during a Windows
    XP/Server 2003 guest installation, turning it on in the &vmguest;
    configuration alone is not sufficient. See the following articles for
    more information:
   </para>
   <simplelist>
    <member><link xlink:href="http://support.microsoft.com/kb/314088/EN-US/"/>
    </member>
    <member><link xlink:href="http://support.microsoft.com/?kbid=309283"/>
    </member>
   </simplelist>
   <para>
    A graceful shutdown is of course always possible from within the guest
    operating system, regardless of the &vmguest;'s configuration.
   </para>
  </tip>

  <sect2 xml:id="sec.libvirt.managing.status.vmm">
   <title>Changing a &vmguest;'s State with &vmm;</title>
   <para>
    Changing a &vmguest;'s state can be done either from &vmm;'s main
    window, or from a VNC window.
   </para>
   <procedure>
    <title>State Change from the &vmm; Window</title>
    <step>
     <para>
      Right-click a &vmguest; entry.
     </para>
    </step>
    <step>
     <para>
      Choose <guimenu>Run</guimenu>, <guimenu>Pause</guimenu>, or one of the
      <guimenu>Shutdown options</guimenu> from the pop-up menu.
     </para>
    </step>
   </procedure>
   <procedure>
    <title>State change from the VNC Window</title>
    <step>
     <para>
      Open a VNC Window as described in
      <xref linkend="sec.libvirt.managing.vnc.vmm"/>.
     </para>
    </step>
    <step>
     <para>
      Choose <guimenu>Run</guimenu>, <guimenu>Pause</guimenu>, or one of the
      <guimenu>Shut Down</guimenu> options either from the toolbar or from
      the <guimenu>Virtual Machine</guimenu> menu.
     </para>
    </step>
   </procedure>
   <sect3 xml:id="sec.libvirt.managing.status.vmm.autostart">
    <title>Autostarting a &vmguest;</title>
    <para>
     Automatically starting a guest when the &vmhost; boots is not
     enabled by default. This feature needs to be turned on for each
     &vmguest; individually. There is no way to activate it globally.
    </para>
    <procedure>
     <step>
      <para>
       Double-click the &vmguest; entry in &vmm; to open its console.
      </para>
     </step>
     <step>
      <para>
       Choose <menuchoice> <guimenu>View</guimenu>
       <guimenu>Details</guimenu></menuchoice> to open the &vmguest;
       configuration window.
      </para>
     </step>
     <step>
      <para>
       Choose <guimenu>Boot Options</guimenu> and check <guimenu>Start
       virtual machine on host boot up</guimenu>.
      </para>
     </step>
     <step>
      <para>
       Save the new configuration with <guimenu>Apply</guimenu>.
      </para>
     </step>
    </procedure>
   </sect3>
  </sect2>

  <sect2 xml:id="sec.libvirt.managing.status.virsh">
   <title>Changing a &vmguest;'s State with <command>virsh</command></title>
   <para>
    In the following examples the state of a &vmguest; named
    <quote>sles12</quote> is changed.
   </para>
   <variablelist>
    <varlistentry>
     <term>Start</term>
     <listitem>
<screen>virsh start sles12</screen>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>Pause</term>
     <listitem>
<screen>virsh suspend sles12</screen>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>Reboot</term>
     <listitem>
<screen>virsh reboot sles12</screen>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>Graceful shutdown</term>
     <listitem>
<screen>virsh shutdown sles12</screen>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>Force shutdown</term>
     <listitem>
<screen>virsh  destroy sles12</screen>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>Turn on autostart</term>
     <listitem>
<screen>virsh autostart sles12</screen>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>Turn off autostart</term>
     <listitem>
<screen>virsh autostart --disable sles12</screen>
     </listitem>
    </varlistentry>
   </variablelist>
  </sect2>
 </sect1>
 <sect1 xml:id="sec.libvirt.manage.save">
  <title>Saving and Restoring the State of a &vmguest;</title>

  <para>
   Saving a &vmguest; preserves the exact state of the guest’s memory.
   The operation is slightly similar to <emphasis>hibernating</emphasis> a
   computer. A saved &vmguest; can be quickly restored to its previously
   saved running condition.
  </para>

  <para>
   When saved, the &vmguest; is paused, its current memory state is saved
   to disk, and then the guest is stopped. The operation does not make a
   copy of any portion of the &vmguest;’s virtual disk. The amount of
   time taken to save the virtual machine depends on the amount of memory
   allocated. When saved, a &vmguest;’s memory is returned to the pool
   of memory available on the &vmhost;.
  </para>

  <para>
   The restore operation loads a &vmguest;’s previously saved memory
   state file and starts it. The guest is not booted but rather resumes at
   the point where it was previously saved. The operation is slightly
   similar to coming out of hibernation.
  </para>

  <para>
   The &vmguest; is saved to a state file. Make sure there is enough
   space on the partition you are going to save to. Issue the following
   command on the guest to get a rough estimation of the file size in
   megabytes to be expected:
  </para>

<screen>free -m | awk '/^Mem:/ {print $3}'</screen>

  <warning>
   <para>
    After using the save operation, do not boot or start the saved
    &vmguest;. Doing so would cause the machine's virtual disk and the
    saved memory state to get out of sync and can result in critical errors
    when restoring the guest. The only "proper" way to use a saved
    &vmguest; is using the restore operation.
   </para>
  </warning>

  <sect2 xml:id="sec.libvirt.manage.save.vmm">
   <title>Saving / Restoring with &vmm;</title>
   <procedure>
    <title>Saving a &vmguest;</title>
    <step>
     <para>
      Open a VNC connection window to a &vmguest;. Make sure the guest is
      running.
     </para>
    </step>
    <step>
     <para>
      Choose <menuchoice> <guimenu>Virtual Machine</guimenu>
      <guimenu>Save</guimenu> </menuchoice>
     </para>
    </step>
    <step>
     <para>
      Choose a location and a file name.
     </para>
    </step>
    <step>
     <para>
      Click <guimenu>Save</guimenu>. Saving the guest's state may take some
      time. After the operation has finished, the &vmguest; will
      automatically shut down.
     </para>
    </step>
   </procedure>
   <procedure>
    <title>Restoring a &vmguest;</title>
    <step>
     <para>
      Start the &vmm;.
     </para>
    </step>
    <step>
     <para>
      Type <keycombo> <keycap function="alt"/> <keycap>R</keycap>
      </keycombo> or choose <menuchoice> <guimenu>File</guimenu>
      <guimenu>Restore Saved Machine</guimenu> </menuchoice>.
     </para>
    </step>
    <step>
     <para>
      Choose the file you want to restore and proceed with
      <guimenu>Open</guimenu>. Once the file has been successfully loaded,
      the &vmguest; is up and running.
     </para>
    </step>
   </procedure>
  </sect2>

  <sect2 xml:id="sec.libvirt.manage.save.virsh">
   <title>Saving / Restoring with <command>virsh</command></title>
   <para>
    Save a running &vmguest; with the command <command>virsh</command>
    <option>save</option> and specify the file to where it is saved.
   </para>
   <variablelist>
    <varlistentry>
     <term>Save the guest named <literal>opensuse13</literal>
     </term>
     <listitem>
<screen>virsh save opensuse13 /virtual/saves/opensuse13.vmsav</screen>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>Save the guest with the ID <literal>37</literal>
     </term>
     <listitem>
<screen>virsh save 37 /virtual/saves/opensuse13.vmsave</screen>
     </listitem>
    </varlistentry>
   </variablelist>
   <para>
    To restore it, use <command>virsh</command> <option>restore</option>:
   </para>
<screen>virsh restore /virtual/saves/opensuse13.vmsave</screen>
  </sect2>
 </sect1>
 <sect1 xml:id="sec.libvirt.managing.snapshots">
  <title>Creating and Managing Snapshots</title>

  <para>
   &vmguest; snapshots are snapshots of the complete virtual machine
   including the state of CPU, RAM, and the content of all writable disks.
   To use virtual machine snapshots, you must have at least one
   non-removable and writable block device using the qcow2 disk image
   format.
  </para>

  <note>
   <para>
    Snapshots are supported on &kvm; &vmhost;s only.
   </para>
  </note>

  <para>
   Snapshots let you restore the state of the machine at a particular point
   in time. This is for example useful to undo a faulty configuration or the
   installation of a lot of packages. It's also helpful for testing
   purposes, since it allows you to go back to a defined state at any time.
  </para>

  <para>
   Snapshots can be taken either from running guests or from a guest
   currently not running. Taking a screenshot from a guest that is shut down
   ensures data integrity. In case you want to create a snapshot from a
   running system, be aware of the fact that the snapshot only captures the
   state of the disk(s), not the state of the memory. Therefore you need to
   ensure that:
  </para>

  <itemizedlist mark="bullet" spacing="normal">
   <listitem>
    <para>
     all running programs have written their data to the disk. If unsure,
     terminate the application and/or stop the respective service.
    </para>
   </listitem>
   <listitem>
    <para>
     buffers have been written to disc. This can be achieved by running the
     command <command>sync</command> on the &vmguest;.
    </para>
   </listitem>
  </itemizedlist>

  <para>
   Starting a snapshot reverts the machine back to the state it was in when
   the snapshot was taken. Any changes written to the disk after that point
   in time will get lost when starting the snapshot. Also note that starting
   a snapshot will restore the state (shut off or running) the machine was
   in when having taken the snapshot. If starting a snapshot of the state
   <literal>Shutoff</literal>, you will have to start the &vmguest;
   afterwards.
  </para>

  <sect2 xml:id="sec.libvirt.managing.snapshots.vmm">
   <title>Creating and Managing Snapshots with &vmm;</title>
   <para>
    To open the snapshot management view in &vmm;, open the VNC window as
    described in <xref linkend="sec.libvirt.managing.vnc.vmm"/>. Now either
    choose <menuchoice> <guimenu>View</guimenu> <guimenu>Snapshots</guimenu>
    </menuchoice> or click the snapshot icon in the toolbar.
   </para>
   <informalfigure>
    <mediaobject>
     <imageobject role="fo">
      <imagedata fileref="virt_vmm_snapshots_list.png" width="75%" format="PNG"/>
     </imageobject>
     <imageobject role="html">
      <imagedata fileref="virt_vmm_snapshots_list.png" width="75%" format="PNG"/>
     </imageobject>
    </mediaobject>
   </informalfigure>
   <para>
    The list of existing snapshots for the chosen &vmguest; is displayed
    in the left-hand part of the window. The snapshot that was last started
    is marked with a green tick. The right-hand part of the window shows
    details of the snapshot currently marked in the list. These details
    include the snapshot's title and time stamp, the state of the
    &vmguest; at the time the snapshot was taken and a description.
    Snapshots from running guests also include a screenshot. The
    <guimenu>Description</guimenu> can be changed or added directly in this
    view; the other snapshot data cannot be changed.
   </para>
   <sect3 xml:id="sec.libvirt.managing.snapshots.vmm.add">
    <title>Creating a Snapshot</title>
    <para>
     To take a new snapshot of a &vmguest;, proceed as follows:
    </para>
    <procedure>
     <step>
      <para>
       Shut down the &vmguest; in case you want to create a snapshot from
       a guest that is not running.
      </para>
     </step>
     <step>
      <para>
       Click the plus symbol in the bottom left corner of the VNC window to
       open the <guimenu>Create Snapshot</guimenu> window.
      </para>
     </step>
     <step>
      <para>
       Provide a <guimenu>Name</guimenu> and, optionally, a description. The
       name cannot be changed once the snapshot has been taken. It is
       recommended to use a <quote>speaking name</quote>, since it makes it
       easier to identify the snapshot.
      </para>
     </step>
     <step>
      <para>
       Once all data is entered, choose <guimenu>Finish</guimenu>.
      </para>
     </step>
    </procedure>
   </sect3>
   <sect3 xml:id="sec.libvirt.managing.snapshots.vmm.delete">
    <title>Deleting a Snapshot</title>
    <para>
     To delete a snapshot of a &vmguest; proceed as follows:
    </para>
    <procedure>
     <step>
      <para>
       Click the symbol with the red circle in the bottom left corner of the
       VNC window.
      </para>
     </step>
     <step>
      <para>
       Confirm the deletion with <guimenu>Yes</guimenu>.
      </para>
     </step>
    </procedure>
   </sect3>
   <sect3 xml:id="sec.libvirt.managing.snapshots.vmm.start">
    <title>Starting a Snapshot</title>
    <para>
     To start a snapshot, proceed as follows:
    </para>
    <procedure>
     <step>
      <para>
       Click the <quote>play</quote> symbol in the bottom left corner of the
       VNC window.
      </para>
     </step>
     <step>
      <para>
       Confirm the start with <guimenu>Yes</guimenu>.
      </para>
     </step>
    </procedure>
   </sect3>
  </sect2>

  <sect2 xml:id="sec.libvirt.managing.snapshots.virsh">
   <title>Creating and Managing Snapshots with <command>virsh</command></title>
   <para>
    To list all existing snapshots for a domain
    (<replaceable>admin_server</replaceable> in the following), run the
    <literal>snapshot-list</literal> command:
   </para>
<screen>&prompt.user;virsh snapshot-list
 Name                 Creation Time             State
------------------------------------------------------------
 Basic installation incl. SMT finished 2013-09-18 09:45:29 +0200 shutoff
 Basic installation incl. SMT for CLOUD3 2013-12-11 15:11:05 +0100 shutoff
 Basic installation incl. SMT for CLOUD3-HA 2014-03-24 13:44:03 +0100 shutoff
 Basic installation incl. SMT for CLOUD4 2014-07-07 11:27:47 +0200 shutoff
 Beta1 Running        2013-07-12 12:27:28 +0200 shutoff
 Beta2 prepared       2013-07-12 17:00:44 +0200 shutoff
 Beta2 running        2013-07-29 12:14:11 +0200 shutoff
 Beta3 admin node deployed 2013-07-30 16:50:40 +0200 shutoff
 Beta3 prepared       2013-07-30 17:07:35 +0200 shutoff
 Beta3 running        2013-09-02 16:13:25 +0200 shutoff
 Cloud2 GM running    2013-12-10 15:44:58 +0100 shutoff
 CLOUD3 RC prepared   2013-12-20 15:30:19 +0100 shutoff
 CLOUD3-HA Build 680 prepared 2014-03-24 14:20:37 +0100 shutoff
 CLOUD3-HA Build 796 installed (zypper up) 2014-04-14 16:45:18 +0200 shutoff
 GMC2 post Cloud install 2013-09-18 10:53:03 +0200 shutoff
 GMC2 pre Cloud install 2013-09-18 10:31:17 +0200 shutoff
 GMC2 prepared (incl. Add-On Installation) 2013-09-17 16:22:37 +0200 shutoff
 GMC_pre prepared     2013-09-03 13:30:38 +0200 shutoff
 OS + SMT + eth[01]   2013-06-14 16:17:24 +0200 shutoff
 OS + SMT + Mirror + eth[01] 2013-07-30 15:50:16 +0200 shutoff</screen>
   <para>
    The snapshot that was last started is shown with the
    <literal>snapshot-current command:</literal>
   </para>
<screen>&prompt.user;virsh snapshot-current --name admin_server
Basic installation incl. SMT for CLOUD4
</screen>
   <para>
    Details about a particular snapshot can be obtained by running the
    <literal>snapshot-info</literal> command:
   </para>
<screen>&prompt.user;virsh snapshot-info sles "Basic installation incl. SMT for CLOUD4"
Name:           Basic installation incl. SMT for CLOUD4
Domain:         admin_server
Current:        yes
State:          shutoff
Location:       internal
Parent:         Basic installation incl. SMT for CLOUD3-HA
Children:       0
Descendants:    0
Metadata:       yes
</screen>
   <sect3 xml:id="sec.libvirt.managing.snapshots.virsh.add">
    <title>Creating a Snapshot</title>
    <para>
     To take a new snapshot of a &vmguest; currently not running, use the
     <literal>snapshot-create-as</literal> command as follows:
    </para>
<screen>virsh snapshot-screate-as --domain admin_server<co xml:id="virsh.snapshot.add.domain"/> --name "Snapshot 1"<co xml:id="virsh.snapshot.add.name"/> \
--description "First snapshot"<co xml:id="virsh.snapshot.add.description"/></screen>
    <calloutlist>
     <callout arearefs="virsh.snapshot.add.domain">
      <para>
       Domain name. Mandatory.
      </para>
     </callout>
     <callout arearefs="virsh.snapshot.add.name">
      <para>
       Name of the snapshot. It is recommended to use a <quote>speaking
       name</quote>, since it makes it easier to identify the snapshot.
       Mandatory.
      </para>
     </callout>
     <callout arearefs="virsh.snapshot.add.description">
      <para>
       Description for the snapshot. Optional.
      </para>
     </callout>
    </calloutlist>
    <para>
     To take a snapshot of a running &vmguest;, you need to specify the
     <option>--live</option> parameter:
    </para>
<screen>virsh snapshot-screate-as --domain admin_server --name "Snapshot 2" \
 --description "First live snapshot" --live</screen>
    <para>
     Refer to the <citetitle>SNAPSHOT COMMANDS</citetitle> section in
     <command>man 1 virsh</command> for more details.
    </para>
   </sect3>
   <sect3 xml:id="sec.libvirt.managing.snapshots.virsh.delete">
    <title>Deleting a Snapshot</title>
    <para>
     To delete a snapshot of a &vmguest;, use the
     <literal>snapshot-delete</literal> command:
    </para>
<screen>virsh snapshot-delete --domain admin_server --snapshotname "Snapshot 2"</screen>
   </sect3>
   <sect3 xml:id="sec.libvirt.managing.snapshots.virsh.start">
    <title>Starting a Snapshot</title>
    <para>
     To start a snapshot, use the <literal>snapshot-revert</literal>
     command:
    </para>
<screen>virsh snapshot-revert --domain admin_server --snapshotname "Snapshot 1"</screen>
    <para>
     To start the current snapshot (the one the &vmguest; was started
     off), it is sufficient to use <option>--current</option> rather than
     specifying the snapshot name:
    </para>
<screen>virsh snapshot-revert --domain admin_server --current</screen>
   </sect3>
  </sect2>
 </sect1>
 <sect1 xml:id="sec.libvirt.managing.delete">
  <title>Deleting a &vmguest;</title>

  <para>
   Deleting a &vmguest; removes its XML configuration by default. Since
   the attached storage is not deleted by default, you will be able to use
   it with another &vmguest;. With &vmm; you may also delete a guest's
   storage files as well&mdash;this will completely erase the guest.
  </para>

  <para>
   In order to delete a &vmguest;, it has to be shut down first (refer to
   <xref linkend="sec.libvirt.managing.status"/> for instructions). It is
   not possible to delete a running guest.
  </para>

  <sect2 xml:id="sec.libvirt.managing.delete.vmm">
   <title>Deleting a &vmguest; with &vmm;</title>
   <procedure>
    <step>
     <para>
      In the &vmm;, right-click a &vmguest; entry.
     </para>
    </step>
    <step>
     <para>
      Choose <guimenu>Delete</guimenu> from the pop-up menu.
     </para>
    </step>
    <step>
     <para>
      A confirmation window opens. Clicking <guimenu>Delete</guimenu> will
      permanently erase the &vmguest;. The deletion is not recoverable.
     </para>
     <para>
      You may also choose to permanently delete the guest's virtual disk by
      ticking <guimenu>Delete Associated Storage Files</guimenu>. The
      deletion is not recoverable either.
     </para>
    </step>
   </procedure>
  </sect2>

  <sect2 xml:id="sec.libvirt.managing.delete.virsh">
   <title>Deleting a &vmguest; with <command>virsh</command></title>
   <para>
    To delete a &vmguest; with <command>virsh</command>, run
    <command>virsh</command> <option>undefine</option>
    <replaceable>VM_NAME</replaceable>.
   </para>
<screen>virsh undefine sles12</screen>
   <para>
    There is no option to automatically delete the attached storage files.
    If they are managed by libvirt, delete them as described in
    <xref linkend="sec.libvirt.storage.virsh.del_volumes"/>.
   </para>
  </sect2>
 </sect1>
</chapter>
