<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE appendix 
[
  <!ENTITY % entities SYSTEM "entity-decl.ent">
  %entities;
]>
<!-- Converted by suse-upgrade version 1.1 -->
<appendix xmlns="http://docbook.org/ns/docbook" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0" xml:id="app.deploy.network_json">
 <title>The Network &Barcl; Template File</title>
 <para>
  The &crow; network &barcl; provides two functions for the system.
  The first is a common role to instantiate network interfaces on the
  &crow; managed systems. The other function is address pool management.
  While the addresses can be managed with the &yast; &crow; module,
  complex network setups require to manually edit the network &barcl;
  template file <filename>/etc/crowbar/network.json</filename>. This section
  explains the file in detail. Settings in this file are applied to all
  nodes in &cloud;.
 </para>
 <warning>
  <title>No Network Changes After Having Run the Cloud Installation Script</title>
  <para>
   After you have run the &cloud; installation script, you cannot change
   the network setup anymore. If doing so, you would need to completely set
   up the Administration Server again.
  </para>
  <para>
   The only exception from this rule is the interface map. This section can
   be changed at a later stage as well. See
   <xref linkend="sec.deploy.network_json.interface_map"/> for details.
  </para>
 </warning>
 <sect1 xml:id="sec.deploy.network_json.edit">
  <title>Editing <filename>network.json</filename></title>

  <para>
   The <filename>network.json</filename> is located in
   <filename>/etc/crowbar/</filename>. To edit it, open it in an editor of
   your choice. The template has the following general structure:
  </para>

<screen>{
   "attributes" : {
      "mode" : "<replaceable>value</replaceable>",
      "start_up_delay" : <replaceable>value</replaceable>,
      "teaming" : { "mode": <replaceable>value</replaceable> },<co xml:id="structure.general"/>
      "network" : {
         "interface_map"<co xml:id="structure.interface_map"/> : [
            ...
         ],
         "conduit_map"<co xml:id="structure.conduit"/> : [
            ...
         ],
         "networks"<co xml:id="structure.networks"/> : {
            ...
         },
      }
   }
}</screen>

  <calloutlist>
   <callout arearefs="structure.general">
    <para>
     General attributes. Refer to
     <xref linkend="sec.deploy.network_json.global"/> for details.
    </para>
   </callout>
   <callout arearefs="structure.interface_map">
    <para>
     Interface map section. Defines the order in which the physical network
     interfaces are to be used. Refer to
     <xref linkend="sec.deploy.network_json.interface_map"/> for details.
    </para>
   </callout>
   <callout arearefs="structure.conduit">
    <para>
     Network conduit section defining the network modes and the network
     interface usage. Refer to
     <xref linkend="sec.deploy.network_json.conduits"/> for details.
    </para>
   </callout>
   <callout arearefs="structure.networks">
    <para>
     Network definition section. Refer to
     <xref linkend="sec.deploy.network_json.networks"/> for details.
    </para>
   </callout>
  </calloutlist>

  <note>
   <title>Order of Elements</title>
   <para>
    The order in which the entries in the <filename>network.json</filename>
    file appear may differ from the one listed above. Use your editor's
    search function to find certain entries.
   </para>
  </note>
 </sect1>
 <sect1 xml:id="sec.deploy.network_json.global">
  <title>Global Attributes</title>

  <para>
   The most important options to define in the global attributes section are
   the default values for the network and bonding modes. The following
   global attributes exist:
  </para>

<screen>"start_up_delay" : 30,<co xml:id="global.startup"/>
         "mode": "single",<co xml:id="global.mode"/>
         "teaming" : { "mode" : 5 },<co xml:id="global.bonding"/></screen>

  <calloutlist>
   <callout arearefs="global.startup">
    <para>
     Time (in seconds) the &chef;-client waits for the network interfaces
     to become online before running into a time-out.
    </para>
   </callout>
   <callout arearefs="global.mode">
    <para>
     Network mode. Defines the configuration name (or name space) to be used
     from the conduit_map (see
     <xref linkend="sec.deploy.network_json.conduits"/>). This allows to
     define multiple configurations (single, dual, and team are
     preconfigured) and switch them by changing this parameter.
    </para>
   </callout>
   <callout arearefs="global.bonding">
    <para>
     Default bonding mode. See
     <link xlink:href="https://www.kernel.org/doc/Documentation/networking/bonding.txt"/>
     for a list of available modes.
    </para>
    <warning>
     <title>Bonding Mode 6 (balance-alb) not supported</title>
     <para>
      Adaptive load balancing (balance-alb or 6) is not supported because of
      problems with bridges and openvswitch.
     </para>
    </warning>
   </callout>
  </calloutlist>
 </sect1>
 <sect1 xml:id="sec.deploy.network_json.interface_map">
  <title>Interface Map</title>

  <para>
   By default physical network interfaces are used in the order they appear
   under <filename>/sys/class/net/</filename>. In case you want to apply a
   different order, you need to create an interface map where you can
   specify a custom order of the bus IDs. Interface maps are created for
   specific hardware configurations and are applied to all machines matching
   this configuration.
  </para>

<screen>            {
               "pattern" : "PowerEdge R610"<co xml:id="interface.pattern"/>,
               "serial_number" : "0x02159F8E"<co xml:id="interface.serial"/>,
               "bus_order" : [<co xml:id="interface.bus"/>
                  "0000:00/0000:00:01",
                  "0000:00/0000:00:03"
               ]
            }</screen>

  <calloutlist>
   <callout arearefs="interface.pattern">
    <para>
     Hardware specific identifier. This identifier can be obtained by
     running the command <command>dmidecode</command> <option>-s
     system-product-name</option> on the machine you want to identify. You
     can log in to a node during the hardware discovery phase (when booting
     the SLEShammer image) via the &admserv;.
    </para>
   </callout>
   <callout arearefs="interface.serial">
    <para>
     Additional hardware specific identifier. This identifier can be used in
     case two machines have the same value for <guimenu>pattern</guimenu>,
     but different interface maps are needed. Specifying this parameter is
     optional (it is not included in the default
     <filename>network.json</filename> file). The serial number of a machine
     can be obtained by running the command <command>dmidecode</command>
     <option>-s system-serial-number</option> on the machine you want to
     identify.
    </para>
   </callout>
   <callout arearefs="interface.bus">
    <para>
     Bus IDs of the interfaces. The order in which they are listed here
     defines the order in which &chef; addresses the interfaces. The IDs
     can be obtained by listing the contents of
     <filename>/sys/class/net/</filename>.
    </para>
   </callout>
  </calloutlist>

  <important>
   <title>PXE Boot Interface must be Listed First</title>
   <para>
    The physical interface used to boot the node via PXE must always be
    listed first.
   </para>
  </important>

  <note>
   <title>Interface Map Changes Allowed after Having Run the &cloud; Installation Script</title>
   <para>
    Contrary to all other sections in <filename>network.json</filename>, you
    can change interface maps after having executed the &cloud;
    installation script. However, nodes that are already deployed and
    affected by these changes need to be deployed again. Therefore it is not
    recommended to make changes to the interface map that affect active
    nodes.
   </para>
   <para>
    If you change the interface mappings after having run the &cloud;
    installation script, you <emphasis>must not</emphasis> make your changes
    by editing <filename>network.json</filename>. You must rather use the
    &crow; Web interface and open <menuchoice>
    <guimenu>Barclamps</guimenu> <guimenu>&crow;</guimenu>
    <guimenu>Network</guimenu> <guimenu>Edit</guimenu></menuchoice>.
    Activate your changes by clicking <guimenu>Apply</guimenu>.
   </para>
  </note>

  <sect2 xml:id="sec.deploy.network_json.interface_map.examples">
   <title>Interface Map Example</title>
   <para/>
   <example xml:id="interface_map.example">
    <title>Changing the Network Interface Order on a Machine with four NICs</title>
    <orderedlist spacing="normal">
     <listitem>
      <para>
       Get the machine identifier by running the following command on the
       machine to which the map should be applied:
      </para>
<screen>~ # dmidecode -s system-product-name
AS 2003R
</screen>
      <para>
       The resulting string needs to be entered on the
       <guimenu>pattern</guimenu> line of the map. It is interpreted as a
       Ruby regular expression (see
       <link xlink:href="http://www.ruby-doc.org/core-2.0/Regexp.html"/> for
       a reference). Unless the pattern starts with <literal>^</literal> and
       ends with <literal>$</literal> a substring match is performed against
       the name return from the above commands.
      </para>
     </listitem>
     <listitem>
      <para>
       List the interface devices in <filename>/sys/class/net</filename> to
       get the current order and the bus ID of each interface:
      </para>
<screen><?dbsuse-fo font-size="6pt"?>~ # ls -lgG /sys/class/net/ | grep eth
lrwxrwxrwx 1 0 Jun 19 08:43 eth0 -&gt; ../../devices/pci0000:00/0000:00:1c.0/0000:09:00.0/net/eth0
lrwxrwxrwx 1 0 Jun 19 08:43 eth1 -&gt; ../../devices/pci0000:00/0000:00:1c.0/0000:09:00.1/net/eth1
lrwxrwxrwx 1 0 Jun 19 08:43 eth2 -&gt; ../../devices/pci0000:00/0000:00:1c.0/0000:09:00.2/net/eth2
lrwxrwxrwx 1 0 Jun 19 08:43 eth3 -&gt; ../../devices/pci0000:00/0000:00:1c.0/0000:09:00.3/net/eth3
</screen>
      <para>
       The bus ID is included in the path of the link target&mdash;it is
       the following string: <filename>../../devices/pci<replaceable>BUS
       ID</replaceable>/net/eth0</filename>
      </para>
     </listitem>
     <listitem>
      <para>
       Create an interface map with the bus ID listed in the order the
       interfaces should be used. Keep in mind that the interface from which
       the node is booted using PXE must be listed first. In the following
       example the default interface order has been changed to
       <systemitem class="resource">eth0</systemitem>,
       <systemitem class="resource">eth2</systemitem>,
       <systemitem class="resource">eth1</systemitem> and
       <systemitem class="resource">eth3</systemitem>.
      </para>
<screen>            {
               "pattern" : "AS 2003R",
               "bus_order" : [
                  "0000:00/0000:00:1c.0/0000:09:00.0",
                  "0000:00/0000:00:1c.0/0000:09:00.2",
                  "0000:00/0000:00:1c.0/0000:09:00.1",
                  "0000:00/0000:00:1c.0/0000:09:00.3"
               ]
            } </screen>
     </listitem>
    </orderedlist>
   </example>
  </sect2>
 </sect1>
 <sect1 xml:id="sec.deploy.network_json.conduits">
  <title>Network Conduits</title>

  <para>
   Network conduits define mappings for logical interfaces&mdash;one or
   more physical interfaces bonded together. Each conduit can be identified
   by a unique name, the <guimenu>pattern</guimenu>. This pattern is also
   called <quote>Network Mode</quote> in this document.
  </para>

  <para>
   Several network modes are already pre-defined. The most important ones
   are:
  </para>

  <simplelist>
   <member><emphasis role="bold">single</emphasis>: Only use the first interface for
    all networks. VLANs will be added on top of this single interface.
   </member>
   <member><emphasis role="bold">dual</emphasis>: Use the first interface as the admin
    interface and the second one for all other networks. VLANs will be added
    on top of the second interface.
   </member>
   <member><emphasis role="bold">team</emphasis>: Bond first two interfaces. VLANs
    will be added on top of the bond.
   </member>
  </simplelist>

  <para>
   See <xref linkend="sec.depl.req.network.modes"/> for detailed
   descriptions. Apart from these modes a fallback mode
   <literal>".*/.*/.*"</literal> is also pre-defined&mdash;it is applied
   in case no other mode matches the one specified in the global attributes
   section. These modes can be adjusted according to your needs. It is also
   possible to define a custom mode.
  </para>

  <para>
   The mode name that is specified with <literal>mode</literal> in the
   global attributes section is deployed on all nodes in &cloud;. It is
   not possible to use a different mode for a certain node. However, you can
   define <quote>sub</quote> modes with the same name that only match
   machines with a certain number of physical network interfaces or machines
   with certain roles (all &compnode;s for example).
  </para>

<screen>         "conduit_map" : [
         ...
            {
               "pattern" : "team/.*/.*"<co xml:id="conduit.pattern"/>,
               "conduit_list" : {
                  "intf2"<co xml:id="conduit.name"/> : {
                     "if_list" : ["1g1","1g2"]<co xml:id="conduit.interface"/>,
                     "team_mode" : 5<co xml:id="conduit.bonding"/>
                  },
                  "intf1" : {
                     "if_list" : ["1g1","1g2"],
                     "team_mode" : 5
                  },
                  "intf0" : {
                     "if_list" : ["1g1","1g2"],
                     "team_mode" : 5
                  }
               }
            },
         ...
         ],</screen>

  <calloutlist>
   <callout arearefs="conduit.pattern">
    <para>
     This line contains the pattern definition for a mode. The value for
     pattern must have the following form:
    </para>
<screen><replaceable>mode_name</replaceable>/<replaceable>number_of_nics</replaceable>/<replaceable>node_role</replaceable></screen>
    <para>
     It is interpreted as a Ruby regular expression (see
     <link xlink:href="http://www.ruby-doc.org/core-2.0/Regexp.html"/> for a
     reference).
    </para>
    <variablelist>
     <varlistentry>
      <term>mode_name
      </term>
      <listitem>
       <para>
        Name of the network mode. This string is used to reference the mode
        from the general attributes section.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>number_of_nics
      </term>
      <listitem>
       <para>
        Normally it is not possible to apply different network modes to
        different roles&mdash;you can only specify one mode in the global
        attributes section. However, it does not make sense to apply a
        network mode that bonds three interfaces on a machine with only two
        physical network interfaces. This option enables you to create modes
        for nodes with a given number of interfaces.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>node_role
      </term>
      <listitem>
       <para>
        This part of the pattern lets you create matches for a certain node
        role. This enables you to create network modes for certain roles,
        for example the &compnode;s (role:
        <guimenu>nova-multi-compute</guimenu>) or the &swift; nodes
        (role: <guimenu>swift-storage</guimenu>). See
        <xref linkend="ex.conduits.role"/> for the full list of roles.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </callout>
   <callout arearefs="conduit.name">
    <para>
     The logical network interface definition. Each conduit list must
     contain at least one such definition. This line defines the name of the
     logical interface. This identifier must be unique and will also be
     referenced in the network definition section. It is recommended to
     stick with the pre-defined naming scheme with <literal>intf0</literal>
     for <quote>Interface 0</quote>, <literal>intf1</literal> for
     <quote>Interface 1</quote>, etc. If you change the name (not
     recommended), you also need to change all references in the network
     definition section.
    </para>
   </callout>
   <callout arearefs="conduit.interface">
    <para>
     This line maps one or more <emphasis>physical</emphasis> interfaces to
     the logical interface. Each entry represents a physical interface. If
     more than one entry exists, the interfaces are bonded&mdash;either
     with the mode defined in the <guimenu>team_mode</guimenu> attribute of
     this conduit section or, if that is not present by the globally defined
     <guimenu>teaming</guimenu> attribute.
    </para>
    <para>
     The physical interfaces definition needs to fit the following pattern:
    </para>
<screen>[Quantifier][Speed][Interface Number]</screen>
    <para>
     Valid examples are <literal>+1g2</literal>, <literal>10g1</literal> or
     <literal>?1g2</literal>.
    </para>
    <variablelist>
     <varlistentry>
      <term>Quantifier</term>
      <listitem>
       <para>
        Specifying the quantifier is optional. The following values may be
        entered:
       </para>
       <simplelist>
        <member><literal>+</literal>: at least the speed specified afterwards
	(specified value or higher)</member>
        <member><literal>-</literal>: at most the speed specified afterwards
	(specified value or lower)</member>
        <member><literal>?</literal>: any speed (speed specified afterwards is
	ignored)</member>
       </simplelist>
       <para>
        If no quantifier is specified, the exact speed specified is used.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>Speed</term>
      <listitem>
       <para>
        Specifying the interface speed is mandatory (even if using the
        <literal>?</literal> quantifier). The following values may be
        entered:
       </para>
       <simplelist>
        <member><literal>10m</literal>: 10 Mbit</member>
        <member><literal>100m</literal>: 100 Mbit</member>
        <member><literal>1g</literal>: 1 Gbit</member>
        <member><literal>10g</literal>: 10 Gbit</member>
       </simplelist>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>Order</term>
      <listitem>
       <para>
        Position in the interface order. Specifying this value is mandatory.
        The interface order is defined by the order in which the interfaces
        appear in <filename>/sys/class/net</filename> (default) or, if
        existing, by an interface map. The order is also linked to the speed
        in this context, so <literal>1g1</literal> means <quote>The first
        1Gbit interface</quote>, <literal>+1g1</literal> means <quote>The
        first 1Gbit or 10Gbit interface</quote>. <literal>?1g1</literal>
        would match the very first interface, regardless of its speed.
       </para>
       <note>
        <title>Ordering Numbers</title>
        <para>
         Ordering numbers start with <literal>1</literal> rather than with
         <literal>0</literal>.
        </para>
       </note>
<!-- fs 2013-08-13:
I am not sure if (and more importantly how) we should document the weird naming that crowbar does internally (See e.g. https://bugzilla.novell.com/show_bug.cgi?id=829648)
Each interfaces that supports multiple speeds can be referenced by multiple internal names. And interface that support 10MBit/s 100MBit/s and 1000MBit/s gets a 10mX, 100mX and a 1gX name. The problem is that the "X" is not always the same for a single interface.
Example: A system with 1x1GBit/s and 1x10GBit/s where the 1GBit/s is defined to be the first interface (e.g. by specifying that in the interface_map) can get the following internal/logical names:

The 1GBit/s interface: 10m1, 100m1, 1g1
The 10GBit/s interface: 10m2, 100m2, 1g2, 10g1

Should we really add this or will it completely confuse everybody?
-->
      </listitem>
     </varlistentry>
    </variablelist>
   </callout>
   <callout arearefs="conduit.bonding">
    <para>
     The bonding mode to be used for this logical interface. Overwrites the
     default set in the global attributes section <emphasis>for this
     interface</emphasis>. See
     <link xlink:href="https://www.kernel.org/doc/Documentation/networking/bonding.txt"/>
     for a list of available modes. Specifying this option is
     optional&mdash;if not specified here, the global setting applies.
    </para>
   </callout>
  </calloutlist>

  <sect2 xml:id="sec.deploy.network_json.conduits.examples">
   <title>Network Conduit Examples</title>
   <para/>
   <example xml:id="ex.conduits.nic_number">
    <title>Network Modes for Different NIC Numbers</title>
    <para>
     The following example defines a network mode named
     <literal>my_mode</literal> for nodes with 6, 3 and an arbitrary number
     of network interfaces. Since the first mode that matches is applied, it
     is important that the specific modes (for 6 and 3 NICs) are listed
     before the general one:
    </para>
<screen>            {
               "pattern" : "my_mode/6/.*",
               "conduit_list" : { ... }
            },
            {
               "pattern" : "my_mode/3/.*",
               "conduit_list" : { ... }
            },
            {
               "pattern" : "my_mode/.*/.*",
               "conduit_list" : { ... }
            },</screen>
   </example>
   <example xml:id="ex.conduits.role">
    <title>Network Modes for Certain Roles</title>
    <para>
     The following example defines network modes for &compnode;s with
     four physical interfaces, the &admserv; (role
     <literal>crowbar</literal>), the &contrnode;, and a general mode
     applying to all other nodes.
    </para>
<screen>            {
               "pattern" : "my_mode/4/nova-multi-compute",
               "conduit_list" : { ... }
            },
            {
               "pattern" : "my_mode/.*/crowbar",
               "conduit_list" : { ... }
            },
            {
               "pattern" : "my_mode/.*/nova-multi-controller",
               "conduit_list" : { ... }
            },
            {
               "pattern" : "my_mode/.*/.*",
               "conduit_list" : { ... }
            },</screen>
    <para>
     The following values for <literal>node_role</literal> can be used:
    </para>
    <simplelist>
     <member><literal>ceph-mon-master</literal>
     </member>
     <member><literal>ceph-mon</literal>
     </member>
     <member><literal>ceph-store</literal>
     </member>
     <member><literal>cinder-controller</literal>
     </member>
     <member><literal>cinder-volume</literal>
     </member>
     <member><literal>crowbar</literal>
     </member>
     <member><literal>database-server</literal>
     </member>
     <member><literal>glance-server</literal>
     </member>
     <member><literal>keystone-server</literal>
     </member>
     <member><literal>nova-multi-compute</literal>
     </member>
     <member><literal>nova-multi-controller</literal>
     </member>
     <member><literal>nova_dashboard-server</literal>
     </member>
     <member><literal>neutron-server</literal>
     </member>
     <member><literal>rabbitmq-server</literal>
     </member>
     <member><literal>swift-dispersion</literal>
     </member>
     <member><literal>swift-proxy</literal>
     </member>
     <member><literal>swift-ring-compute</literal>
     </member>
     <member><literal>swift-storage</literal>
     </member>
    </simplelist>
    <para>
     The role <literal>crowbar</literal> refers to the &admserv;.
    </para>
   </example>
   <example xml:id="ex.conduits.machine">
    <title>Network Modes for Certain Machines</title>
    <para>
     Apart from the roles listed under <xref linkend="ex.conduits.role"/>
     each node in &cloud; has a unique role, which lets you create modes
     matching exactly one node. The role is named after the scheme
     <literal>crowbar-d <replaceable>FULLY QUALIFIED
     HOSTNAME</replaceable></literal>. The <replaceable>FULLY QUALIFIED
     HOSTNAME</replaceable> in turn is composed of the MAC address of the
     network interface used to boot the node via PXE and the domain name
     configured on the &admserv;. Colons and periods are replaced with
     underscores. An example role name would be:
     <literal>crowbar-d1a-12-05-1e-35-49_my_cloud</literal>.
    </para>
    <para>
     Network mode definitions for certain machines must be listed first in
     the conduit map to make sure no other, general rules which would also
     map, are applied.
    </para>
<screen>            {
               "pattern" : "my_mode/.*/crowbar-d1a-12-05-1e-35-49_my_cloud",
               "conduit_list" : { ... }
            },</screen>
   </example>
<!--
    More and complex examples with conduit lists needed
   -->
  </sect2>
 </sect1>
 <sect1 xml:id="sec.deploy.network_json.networks">
  <title>Network Definitions</title>

  <para>
   The network definitions contain IP address assignments, the bridge and
   VLAN setup and settings for the router preference. Each network is also
   assigned to a logical interface defined in the network conduit section.
   In the following the network definition is explained using the example of
   the admin network definition:
  </para>

<screen>    "admin" : {
       "conduit" : "intf0"<co xml:id="network.conduit"/>,
       "add_bridge" : false<co xml:id="network.bridge"/>,
       "use_vlan" : false<co xml:id="network.vlan"/>,
       "vlan" : 100<co xml:id="network.vlanid"/>,
       "router_pref" : 10<co xml:id="network.routerpref"/>,
       "subnet" : "192.168.124.0"<co xml:id="network.addresses"/>,
       "netmask" : "255.255.255.0",
       "router" : "192.168.124.1",
       "broadcast" : "192.168.124.255",
       "ranges" : {
          "admin" : { "start" : "192.168.124.10",
                      "end" : "192.168.124.11" },
          "switch" : { "start" : "192.168.124.241",
                        "end" : "192.168.124.250" },
          "dhcp" : { "start" : "192.168.124.21",
                     "end" : "192.168.124.80" },
          "host" : { "start" : "192.168.124.81",
                     "end" : "192.168.124.160" }
       }
    },
  </screen>

  <calloutlist>
   <callout arearefs="network.conduit">
    <para>
     Logical interface assignment. The interface must be defined in the
     network conduit section and must be part of the active network mode.
    </para>
   </callout>
   <callout arearefs="network.bridge">
    <para>
     Bridge setup. Do not touch. Should be <literal>false</literal> for all
     networks.
    </para>
   </callout>
   <callout arearefs="network.vlan">
    <para>
     Create a VLAN for this network. Changing this setting is not
     recommended.
    </para>
   </callout>
   <callout arearefs="network.vlanid">
    <para>
     ID of the VLAN. Change this to the VLAN ID you intend to use for the
     specific network if required. This setting can also be changed using
     the YaST Crowbar interface. The VLAN ID for the
     <literal>nova-floating</literal> network must always match the one for
     the <literal>public network</literal>.
    </para>
   </callout>
   <callout arearefs="network.routerpref">
    <para>
     Router preference, used to set the default route. On nodes hosting
     multiple networks the router with the lowest
     <literal>router_pref</literal> becomes the default gateway. Changing
     this setting is not recommended.
    </para>
   </callout>
   <callout arearefs="network.addresses">
    <para>
     Network address assignments. These values can also be changed by using
     the &yast; &crow; interface.
    </para>
   </callout>
  </calloutlist>
  <important>
   <title>VLAN Settings</title>
   <para>
    As of &productname; &productnumber;, using a VLAN for the admin network is
    only supported on a native/untagged VLAN. If you need VLAN support for the
    admin network, it must be handled at switch level.
   </para>
   <para>
    When deploying &compnode;s with Microsoft Hyper-V or Windows Server, you
    must <emphasis>not</emphasis> use openvswitch with gre, but rather
    openvswitch with VLAN (recommended) or linuxbridge as a plugin for
    &o_netw;.
   </para>
   <para>
    When changing the network configuration with &yast; or by editing
    <filename>/etc/crowbar/network.json</filename> you can define VLAN
    settings for each network. For the networks <literal>nova-fixed</literal>
    and <literal>nova-floating</literal>, however, special rules apply:
   </para>
   <para>
    <emphasis role="bold">nova-fixed</emphasis>: The <guimenu>USE
    VLAN</guimenu> setting will be ignored. However, VLANs will automatically
    be used if deploying &o_netw; with VLAN support (using the plugins
    linuxbridge, openvswitch plus VLAN or cisco plus VLAN). In this case, you
    need to specify a correct <guimenu>VLAN ID</guimenu> for this network.
   </para>
   <para>
    <emphasis role="bold">nova-floating</emphasis>: When using a VLAN for
    <literal>nova-floating</literal> (which is the default), the <guimenu>USE
    VLAN</guimenu> and <guimenu>VLAN ID</guimenu> setttings for
    <guimenu>nova-floating</guimenu> and <guimenu>public</guimenu> need to be
    the same. When not using a VLAN for <literal>nova-floating</literal>, it
    needs to use a different physical network interface than the
    <literal>nova_fixed</literal> network.
   </para>
  </important>
 </sect1>
</appendix>
